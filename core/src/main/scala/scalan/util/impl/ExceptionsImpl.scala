package scalan.util

import scalan._
import scala.reflect.runtime.universe.{WeakTypeTag, weakTypeTag}
import scalan.meta.ScalanAst._

package impl {
// Abs -----------------------------------
trait ExceptionsDefs extends scalan.Scalan with Exceptions {
  self: Scalan =>

  // entityProxy: single proxy for each type family
  implicit def proxySThrowable(p: Rep[SThrowable]): SThrowable = {
    proxyOps[SThrowable](p)(scala.reflect.classTag[SThrowable])
  }

  implicit def unwrapValueOfSThrowable(w: Rep[SThrowable]): Rep[Throwable] = w.wrappedValue

  implicit lazy val throwableElement: Elem[Throwable] =
    element[SThrowable].asInstanceOf[WrapperElem[_, _]].baseElem.asInstanceOf[Elem[Throwable]]

  // familyElem
  class SThrowableElem[To <: SThrowable]
    extends WrapperElem[Throwable, To] {
    lazy val parent: Option[Elem[_]] = None
    lazy val typeArgs = TypeArgs()
    override lazy val tag = {
      weakTypeTag[SThrowable].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Def[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[SThrowable] => convertSThrowable(x) }
      tryConvert(element[SThrowable], this, x, conv)
    }

    def convertSThrowable(x: Rep[SThrowable]): Rep[To] = {
      x.elem match {
        case _: SThrowableElem[_] => x.asRep[To]
        case e => !!!(s"Expected $x to have SThrowableElem[_], but got $e", x)
      }
    }
    lazy val baseElem = {
      new BaseTypeElem[Throwable, SThrowable](this.asInstanceOf[Elem[SThrowable]])
    }
    lazy val eTo: Elem[_] = new SThrowableImplElem(isoSThrowableImpl)
    override def getDefaultRep: Rep[To] = ???
  }

  implicit def sThrowableElement: Elem[SThrowable] =
    elemCache.getOrElseUpdate(
      (classOf[SThrowableElem[SThrowable]], Nil),
      new SThrowableElem[SThrowable]).asInstanceOf[Elem[SThrowable]]

  implicit case object SThrowableCompanionElem extends CompanionElem[SThrowableCompanionCtor] {
    lazy val tag = weakTypeTag[SThrowableCompanionCtor]
    protected def getDefaultRep = SThrowable
  }

  abstract class SThrowableCompanionCtor extends CompanionDef[SThrowableCompanionCtor] with SThrowableCompanion {
    def selfType = SThrowableCompanionElem
    override def toString = "SThrowable"
  }
  implicit def proxySThrowableCompanionCtor(p: Rep[SThrowableCompanionCtor]): SThrowableCompanionCtor =
    proxyOps[SThrowableCompanionCtor](p)

  // default wrapper implementation
  abstract class SThrowableImpl(val wrappedValue: Rep[Throwable]) extends SThrowable with Def[SThrowableImpl] {
    lazy val selfType = element[SThrowableImpl]

    def getMessage: Rep[String] =
      methodCallEx[String](self,
        this.getClass.getMethod("getMessage"),
        List())

    def initCause(cause: Rep[SThrowable]): Rep[SThrowable] =
      methodCallEx[SThrowable](self,
        this.getClass.getMethod("initCause", classOf[AnyRef]),
        List(cause.asInstanceOf[AnyRef]))
  }
  case class SThrowableImplCtor(override val wrappedValue: Rep[Throwable]) extends SThrowableImpl(wrappedValue) {
  }
  trait SThrowableImplCompanion
  // elem for concrete class
  class SThrowableImplElem(val iso: Iso[SThrowableImplData, SThrowableImpl])
    extends SThrowableElem[SThrowableImpl]
    with ConcreteElem[SThrowableImplData, SThrowableImpl] {
    override lazy val parent: Option[Elem[_]] = Some(sThrowableElement)
    override lazy val typeArgs = TypeArgs()
    override lazy val eTo: Elem[_] = this
    override def convertSThrowable(x: Rep[SThrowable]) = // Converter is not generated by meta
!!!("Cannot convert from SThrowable to SThrowableImpl: missing fields List(wrappedValue)")
    override def getDefaultRep = SThrowableImpl(DefaultOfThrowable)
    override lazy val tag = {
      weakTypeTag[SThrowableImpl]
    }
  }

  // state representation type
  type SThrowableImplData = Throwable

  // 3) Iso for concrete class
  class SThrowableImplIso
    extends EntityIso[SThrowableImplData, SThrowableImpl] with Def[SThrowableImplIso] {
    override def from(p: Rep[SThrowableImpl]) =
      p.wrappedValue
    override def to(p: Rep[Throwable]) = {
      val wrappedValue = p
      SThrowableImpl(wrappedValue)
    }
    lazy val eFrom = element[Throwable]
    lazy val eTo = new SThrowableImplElem(self)
    lazy val selfType = new SThrowableImplIsoElem
    def productArity = 0
    def productElement(n: Int) = ???
  }
  case class SThrowableImplIsoElem() extends Elem[SThrowableImplIso] {
    def getDefaultRep = reifyObject(new SThrowableImplIso())
    lazy val tag = {
      weakTypeTag[SThrowableImplIso]
    }
    lazy val typeArgs = TypeArgs()
  }
  // 4) constructor and deconstructor
  class SThrowableImplCompanionCtor extends CompanionDef[SThrowableImplCompanionCtor] {
    def selfType = SThrowableImplCompanionElem
    override def toString = "SThrowableImplCompanion"

    @scalan.OverloadId("fromFields")
    def apply(wrappedValue: Rep[Throwable]): Rep[SThrowableImpl] =
      mkSThrowableImpl(wrappedValue)

    def unapply(p: Rep[SThrowable]) = unmkSThrowableImpl(p)
  }
  lazy val SThrowableImplRep: Rep[SThrowableImplCompanionCtor] = new SThrowableImplCompanionCtor
  lazy val SThrowableImpl: SThrowableImplCompanionCtor = proxySThrowableImplCompanion(SThrowableImplRep)
  implicit def proxySThrowableImplCompanion(p: Rep[SThrowableImplCompanionCtor]): SThrowableImplCompanionCtor = {
    proxyOps[SThrowableImplCompanionCtor](p)
  }

  implicit case object SThrowableImplCompanionElem extends CompanionElem[SThrowableImplCompanionCtor] {
    lazy val tag = weakTypeTag[SThrowableImplCompanionCtor]
    protected def getDefaultRep = SThrowableImplRep
  }

  implicit def proxySThrowableImpl(p: Rep[SThrowableImpl]): SThrowableImpl =
    proxyOps[SThrowableImpl](p)

  implicit class ExtendedSThrowableImpl(p: Rep[SThrowableImpl]) {
    def toData: Rep[SThrowableImplData] = isoSThrowableImpl.from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoSThrowableImpl: Iso[SThrowableImplData, SThrowableImpl] =
    reifyObject(new SThrowableImplIso())

  registerModule(ExceptionsModule)

  lazy val SThrowable: Rep[SThrowableCompanionCtor] = new SThrowableCompanionCtor {
    def apply(msg: Rep[String]): Rep[SThrowable] =
      newObjEx[SThrowable](msg)
  }

  object SThrowableImplMethods {
  }

  def mkSThrowableImpl
    (wrappedValue: Rep[Throwable]): Rep[SThrowableImpl] = {
    new SThrowableImplCtor(wrappedValue)
  }
  def unmkSThrowableImpl(p: Rep[SThrowable]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: SThrowableImplElem @unchecked =>
      Some((p.asRep[SThrowableImpl].wrappedValue))
    case _ =>
      None
  }

  object SThrowableMethods {
    object getMessage {
      def unapply(d: Def[_]): Option[Rep[SThrowable]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[SThrowableElem[_]] && method.getName == "getMessage" =>
          Some(receiver).asInstanceOf[Option[Rep[SThrowable]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[SThrowable]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object initCause {
      def unapply(d: Def[_]): Option[(Rep[SThrowable], Rep[SThrowable])] = d match {
        case MethodCall(receiver, method, Seq(cause, _*), _) if receiver.elem.isInstanceOf[SThrowableElem[_]] && method.getName == "initCause" =>
          Some((receiver, cause)).asInstanceOf[Option[(Rep[SThrowable], Rep[SThrowable])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[SThrowable], Rep[SThrowable])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object SThrowableCompanionMethods {
    object apply {
      def unapply(d: Def[_]): Option[Rep[String]] = d match {
        case MethodCall(receiver, method, Seq(msg, _*), _) if receiver.elem == SThrowableCompanionElem && method.getName == "apply" =>
          Some(msg).asInstanceOf[Option[Rep[String]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[String]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }
}

object ExceptionsModule extends scalan.ModuleInfo {
  val dump = "H4sIAAAAAAAAALVVTWhcRRyffZtmPwlNWiV+gDU8aZG6Gy3SQpQSNpuibJPQFw2spTL73mQzdd5747zZ5D0p9daD3kQ8iB4KipciiDcREbUgIj30Jh6lIIil9GDxUHE+3lc22aQe3MMw8/Y//4/f7/f/z7U/wYGAgSOBDQn0Gi7isGGp/XzATeus7wwIWkDrH/1tb62UT1UMMNUF4xswWAhIF1T0ph3SdG9xpwMmF7HntD2OeWS6ygUHjY6O0ZQxmrvFMHO35jpgWh7XGKQUsSFfzz+Yr+2XhcsK9GwUcJ8FHDypfTRtnxBkc+x7Tey6Aw57BDU7OODCfqznO9Gb4DIodsBB2/dshjiyWgQGAQri72Uk3eP0XFHnaJlmMXbmucog5iJNEeOgtj+HqBV5vhe5HEzEqS1TmZawqaGQCmxfcilRYQ50QAm71Gc8iVoSETZ8JzmOeVB8AFOdi3ATNkXUftPiDHt96YxC+w3YR0vCRJqPixoCRNZXI4pi57WAO9vihRQAQKlQynMqtUaGWiNFrSFRMy3EMCT4LSj/XGF+GAH9KxQBCKWL4/u4SDygtueY75y3X7tn1VxDXg5lMhWVUlk4emKEahVBAt0fz70X3D1z9aQBql1QxcF8L+AM2jwvhBiwGvQ8n6ucUwwh6wsOZ0ZxqKLMC5shoVRs36XQE55iNOuCKoJtzKWx/DYREzQC/RKnKDEthrSQ1juqS+XdeUpJ9P2lby799vgvk4YWZkhZzm1RuN2jHCXJFiRElGPwJLiIWtV0Wb6LJmfu4gtX3+UGKHRAIdwusOXeRUHnXMhAXd/Q8v0Hn7z/68Q6N2L2RxaRxP+69O13v986PWYAYztOFVGAJWYNS5LjoGqtbjB/S0pHSUMuj6S7WqyX0UFTDo/+cdu5PgvOq8oU8wkADyQ24WLq1IdfPYVWPjdAuau6c5HAvpKd5GABBXYXlP1NxPT30iYkcrer9EoOWocDwmPm8iBoFo+MZJEiidCcathCUn5NE7Lke8hcXDH/sn56/5rkQ/7/MAf1LTUonVchGeg5Ns1BUUykuPj4S2Un1hrhGGe5zCjjx9RZDLKMHjlLlEHu7r7YJmPyiytXHrrzyeuHVCOXe5i7kJqz/6GNk677H9sU5MCaVOvhBLgJeSt+jEQ12lAuRxOL3XSsUX12h5ozgLOzDnV8jxzq7bCVFDyb51Uux4aCvLBfUMWk6L9DWd6tPJyaZSrXR4dZl+szmVYOC/4bI/hfQDaBDDlSPMgVD6Vm9sQHp9denl57RTVr3VFG+p+0M3Z/1s9COqeG0LE9niBhZLZdyiO5OfHDizff/vmzT9X0yuoXjLVDG9E4aC3Of8AxSYuaGVGUFctIKOHyvY+Xnr7x5S016qpSkKJDvfRRz9QXDrXiuPaXQ5WDManPHOktuZz5F8r7eWfhCQAA"
}
}

trait ExceptionsModule extends scalan.util.impl.ExceptionsDefs {self: Scalan =>}
