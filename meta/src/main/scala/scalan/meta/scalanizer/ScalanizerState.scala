package scalan.meta.scalanizer

import scala.tools.nsc.Global
import scalan.meta.ScalanAst.{SValDef, STpeExpr, STpeFunc, STpeEmpty, SModuleDef, STpeTuple, KernelType, SFunc, WrapperDescr}

/** The object contains the current state and temporary data of the Scalanizer. */
trait ScalanizerState[G <: Global] {
  import scala.collection.mutable.Map
  val scalanizer: Scalanizer[G]
  import scalanizer._
  import global._

  /** Mapping of module name to its extensions that should be generated by the plugin.
    * For example: Segments -> Set(SegmentsDsl, SegmentsDslStd, SegmentsDslExp) */
  val subcakesOfModule: Map[String, Set[String]]

  /** Mapping between modules and another modules used by them.
    * For example "Vecs" -> List("NumMonoids", "Cols", "LinearAlgebra") */
  val dependenceOfModule: Map[String, List[String]]

  /** Mapping of module name to the package where it is defined.
    * For example "Cols" -> "scalanizer.collections" */
  val packageOfModule: Map[String, String]

  def updateWrapper(typeName: String, descr: WrapperDescr) = {
    scalanizer.context.wrappers(typeName) = descr
  }
  /** Names of external types. They must be read only after the WrapFrontend phase. */
  def externalTypes = scalanizer.context.wrappers.keySet

  def hasWrapper(typeName: String) = scalanizer.context.wrappers.contains(typeName)
  def getWrapper(typeName: String) = scalanizer.context.wrappers.get(typeName)

  def forEachWrapper(action: ((String, WrapperDescr)) => Unit) = {
    scalanizer.context.wrappers.foreach(action)
  }

  def transformWrappers(transformer: ((String, WrapperDescr)) => WrapperDescr) = {
    scalanizer.context.wrappers.transform(scala.Function.untupled(transformer))
  }

  def getModule(packageName: String, unitName: String): SModuleDef = {
    scalanizer.context.getModule(packageName, unitName)
  }

  def addModule(unitName: String, module: SModuleDef) = {
    scalanizer.context.addModule(unitName, module)
  }
}
